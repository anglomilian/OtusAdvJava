### Сборщик мусора. ДЗ.

#### Домашнее задание:
Сравнение разных сборщиков мусора
Цель: на примере простого приложения понять какое влияние оказывают сборщики мусора
Написать приложение, которое следит за сборками мусора, пишет в лог количество сборок каждого типа
(young, old) и время, которое ушло на сборки в минуту.

Добиться OutOfMemory в этом приложении через медленное подтекание по памяти
(например добавлять элементы в List и удалять только половину).

Настроить приложение (можно добавлять Thread.sleep(...)) так, чтобы оно падало
с OOM примерно через 5 минут после начала работы.

Собрать статистику (количество сборок, время на сборки) по разным GC.

#### Таблица с результатами измерений:
Параметры запуска: 
-Xms128m
-Xmx128m
-XX:+Use<GCName>
-Xlog:gc=debug:file=/Users/anglomilian/gc/gc-%p-%t.log:tags,uptime,time,level

Тестирование проводилось с размером heap 128Mb, тестировались 4 Garbage collector'а: G1, CMS, Parallel, Serial 

| GC type     | OOM Time | Stop The World | Young collections (n/t)  | Full  collections (n/t)  | 
|-------------|----------|----------------|--------------------------|--------------------------|
| G1          | 7m 04s   |     1050ms     |          38 / 422ms      |           5 /  610ms     |
| CMS         | 2m 55s   |     3318ms     |          14 / 269ms      |          10 / 2611ms     |
| Parallel    | 1m 17s   |     9566ms     |          10 / 204ms      |          60 / 9362ms     |
| Serial      | 1m 42s   |     2056ms     |           8 / 148ms      |          12 / 1908ms     |

Приложение использовало добавление элементов типа String в ArrayList для эмуляции подтекания памяти.
Параметры приложения такие как количество добавляемых/удаляемых элементов оставалось неизменными, менялись только GC. 

#### Выводы:
По результатам получилось, что G1 далеко впереди по всем параметрам - дольше всех продержался до OOM, STW тоже самый короткий из всех. Единственным его недостатком можно считать очень высокую нагрузку на процессор, что может быть проблемой, когда требуется максимальная производительность.
Использовать в нынешних реалиях Serial вряд ли целесообразно из-за его однопоточности. CMS будет выведен из эксплуатации в ближайших обновлениях. 
Возможно, при небольшой нагрузке на GC со сборкой мог бы справится и Parallel, он начинает проседать только на сборках Old Generation, так как у него она ведется в одном потоке и для маркировки участков памяти в секции Old ему нужно делать STW.
Скорее всего, в основном сейчас будет широко использоваться именно G1 и в последствии более новые GC. Да, они потребляют больше ресурсов процессора, но сейчас на мультипроцессорных серверах вполне можно позволить добавить вычислительных мощностей именно под GC. 
