### Сборщик мусора. ДЗ.

#### Домашнее задание:
Сравнение разных сборщиков мусора
Цель: на примере простого приложения понять какое влияние оказывают сборщики мусора
Написать приложение, которое следит за сборками мусора, пишет в лог количество сборок каждого типа
(young, old) и время, которое ушло на сборки в минуту.

Добиться OutOfMemory в этом приложении через медленное подтекание по памяти
(например добавлять элементы в List и удалять только половину).

Настроить приложение (можно добавлять Thread.sleep(...)) так, чтобы оно падало
с OOM примерно через 5 минут после начала работы.

Собрать статистику (количество сборок, время на сборки) по разным GC.

#### Таблица с результатами измерений:
Прошлый эксперимент в файле Readme.md
Параметры запуска: 
-Xms512m
-Xmx512m
-XX:+Use<GCName>
-Xlog:gc=debug:file=/Users/anglomilian/gc/gc-%p-%t.log:tags,uptime,time,level

Тестирование проводилось с размером heap 128Mb, тестировались 4 Garbage collector'а: G1, CMS, Parallel, Serial 

| GC type     | OOM Time | Stop The World | Young collections (n/t)  | Full  collections (n/t)  |  Add elements cycles number  |
|-------------|----------|----------------|--------------------------|--------------------------|------------------------------|
| G1          | 14m 59s  |    28249ms     |          72 / 1026ms     |          66 / 27211ms    |            451               |
| CMS         |  8m 52s  |    94354ms     |          13 / 774ms      |          83 / 85734ms    |            437               |
| Parallel    |  4m 47s  |    30307ms     |           7 / 306ms      |          55 / 29992ms    |            353               |
| Serial      |  8m 53s  |   109835ms     |           7 / 664ms      |         158 / 109171ms   |            436               |

По сравнению с предыдущим вариантом тестирования на heap 128Gb, пришлось немного модифицировать приложение.  
Теперь приложение добавляет элементы класса Book в ArrayList для эмуляции подтекания памяти.

Параметры приложения такие как количество добавляемых/удаляемых элементов оставалось неизменными, менялись только GC. 

#### Выводы:
Преимущество по прежнему за G1, но теперь оно совсем не такое красивое - да, G1 продержался гораздо дольше остальных и STW был самый маленький, однако процесс выполнил совсем не на много больше работы по сравнению с CMS и Serial. Очевидно, что дело в использовании процессора, которое в среднем было около 50%, а под конец, перед OOM доходило до максимума.
Интересно, что старенький Serial сработал на уровне CMS практически по всем параметрам. Думаю, что это связано с тем, что наш тестируемый процесс однопоточный. Если бы у нас обработка данных шла в несколько потоков, то разница была бы существенная.
Parallel в этом сценарии продержался меньше всех, однако за короткое время выполнил 80% работы по сравнению с остальными, загрузка процессора на графиках, правда, была очень низкой не выше 12-13%.

В итоге G1 все равно выглядит привлекательнее, особенно с учетом прошлого круга испытаний, где в более узких рамках он смог быстрее приспособиться и продержаться гораздо дольше остальных. Ну и то, что у него самое низкое значение STW будет предпочтительнее для приложений по обслуживанию клиентов в реальном времени.
